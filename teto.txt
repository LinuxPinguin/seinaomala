.ata_lba_read:

  movl %esp, %ebp
  addl $0x04, %ebp

  push %eax
  push %ebx
  push %ecx
  push %edx
  push %edi

  # Configuração do cabeçote e modo LBA
  movb (%ebp), %al  
  andb $0x0F, %al  # Pegando apenas os 4 bits mais baixos
  or $0xE0, %al    # LBA | Master
  movw $DRIVE_HEAD, %dx
  outb %al, %dx

  # Configurando a quantidade de setores para leitura
  movb 4(%ebp), %al
  movw $SECTOR_COUNT, %dx
  outb %al, %dx

  # Configurando o endereço LBA
  movl 8(%ebp), %eax 
  movw $LBA_LOW, %dx
  outb %al, %dx

  shrl $8, %eax
  movw $LBA_MID, %dx
  outb %al, %dx

  shrl $8, %eax
  movw $LBA_HIGH, %dx
  outb %al, %dx

  # Enviando comando de leitura
  movb $COMMAND_READ, %al
  movw $COMMAND_PORT, %dx
  outb %al, %dx
  
  # Verificando se ocorreu erro
  movw $ERROR_PORT, %dx
  inb %dx, %al
  test %al, %al
  jz .noerror

  push $.error_str
  call .vga_write_screen
  jmp .end

  .noerror:
    movw $STATUS_PORT, %dx

  .wait_data:
    inb %dx, %al
    test $0x08, %al  # Bit de dados prontos
    jnz .data_ready
    jmp .wait_data   # Continua esperando

  .data_ready:
  
  # Cálculo do número de palavras a ler
  movb 4(%ebp), %cl
  movw $SECTOR_SIZE, %ax
  mulb %cl
  shr $1, %ax
  movl %eax, %ecx
  movl 12(%ebp), %edi
  movw $DATA_PORT, %dx
  cld
  rep insw

  movl %edi, %esi

  .end:
  pop %edi
  pop %edx
  pop %ecx
  pop %ebx
  pop %eax
  ret
